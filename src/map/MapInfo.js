import React from "react";
import tileData, {WORMHOLE_SYMBOLS, EXPANSIONS} from "../data/tileData";
import boardData from "../data/boardData.json";
import raceData from "../data/raceData.json";

class MapInfo extends React.Component{
    constructor(prop){
        super(prop);
        this.state = {
            lengendaries: [],
            resources: -1,
            influence: -1,
            spaceStations: -1
        };
        this.fillLegendaries = this.fillLegendaries.bind(this);
        this.fillResources = this.fillResources.bind(this);
        this.fillInfluences = this.fillInfluences.bind(this);
        this.fillSpaceStations = this.fillSpaceStations.bind(this);        
    };
    
    componentDidMount() {
    // Check 1: Does the tiles prop exist?
    // Check 2: Is the tiles array not empty?
    if (this.props.tiles && this.props.tiles.length > 0) {
        console.log("MapInfo: Processing initial map.");
        this.fillLegendaries(this.props.tiles);
        this.fillResources(this.props.tiles);
        this.fillInfluences(this.props.tiles);
        this.fillSpaceStations(this.props.tiles);
    } else {
        // Handle the 'no tiles' case explicitly
        console.log("MapInfo: No tiles passed on initial load. State remains empty.");
        // Since state is already initialized to legendaries: [], no further action is needed here.
        }
    }   

    /**
     * Executes every time new props or state are received.
     * CRITICAL: Used to detect when a new map is generated by the parent.
     */
    componentDidUpdate(prevProps) {
        // ðŸ›‘ CRITICAL CHECK: Only run if the 'tiles' array reference has changed.
        if (this.props.tiles !== prevProps.tiles) {
            console.log("MapInfo: Detecting new map generation. Resetting state.");
            
            if (this.props.tiles && this.props.tiles.length > 0) {
                // 1. Reset state to an empty array before processing the NEW map
                this.setState({ legendaries: [] }, () => {
                    // 2. Process the new tiles after the state is guaranteed to be clear
                    this.fillLegendaries(this.props.tiles);
                    this.fillResources(this.props.tiles);
                    this.fillInfluences(this.props.tiles);
                    this.fillSpaceStations(this.props.tiles);
                });
            }
        }
    }

    fillLegendaries(tiles){
        const newLegendaryPlanets = [];
        // iterate through all the map tiles
        for (const tile of tiles){
            const currentTileData = tileData.all[tile];
            // checks if the tile has planets
            if (currentTileData !== undefined && currentTileData.planets.length !== 0){
                let planets = currentTileData.planets; 
                const legendaryPlanetsinTile = planets.find(planet => planet.legendary === true);
                //if there are legendary planets add them to list
                if (legendaryPlanetsinTile !== undefined){
                    //console.log(planets.filter(planet => planet.legendary === true));
                    newLegendaryPlanets.push(legendaryPlanetsinTile);
                }
            }
        };
        if (newLegendaryPlanets.length > 0) {
            this.setState(prevState => ({
                // merge new state
                legendaries : newLegendaryPlanets
            }), () => {
                console.log(`Final total legendaries processed: ${this.state.legendaries.length}`);
                console.log(this.state.legendaries)
            });
        }
    }

    fillResources(tiles){
        let newResource = 0;
        for (let tile of tiles){
            const currentTileData = tileData.all[tile];

            //console.log(currentTileData);
            // checks if the tile has planets
            if (currentTileData !== undefined && currentTileData.planets.length !== 0){
                if (currentTileData.type === "green"){
                   //console.log(currentTileData);
                   continue;
                }
                let planets = currentTileData.planets;
                //console.log(planets);
                for (const planet of planets){
                    //console.log(planet);
                    if (planet.resources){
                        //console.log(planet.name + " : " + planet.resources);
                        newResource += planet.resources;
                    }
                } 
            }
        }
        // update resource state
        this.setState({
                // No need for prevState here since 'newResource' is a complete, fresh value.
                resources : newResource
            }, () => {
                console.log(`Updated Resources processed: ${this.state.resources}`);
            });


    }

        fillInfluences(tiles){
        let newInfluence = 0;
        for (let tile of tiles){
            const currentTileData = tileData.all[tile];

            //console.log(currentTileData);
            // checks if the tile has planets
            if (currentTileData !== undefined && currentTileData.planets.length !== 0){
                if (currentTileData.type === "green"){
                   //console.log(currentTileData);
                   continue;
                }
                let planets = currentTileData.planets;
                //console.log(planets);
                for (const planet of planets){
                    //console.log(planet);
                    if (planet.influence){
                        //console.log(planet.name + " : " + planet.resources);
                        newInfluence += planet.influence;
                    }
                } 
            }
        }
        // update influence state state
        this.setState({
                // No need for prevState here since 'newResource' is a complete, fresh value.
                influence : newInfluence
            }, () => {
                console.log(`Updated Influence processed: ${this.state.influence}`);
            });


    }

        fillSpaceStations(tiles){
        let newSpaceStations = 0;
        for (let tile of tiles){
            const currentTileData = tileData.all[tile];

            //console.log(currentTileData);
            // checks if the tile has planets
            if (currentTileData !== undefined && currentTileData.planets.length !== 0){
                if (currentTileData.type === "green"){
                   //console.log(currentTileData);
                   continue;
                }
                let planets = currentTileData.planets;
                //console.log(planets);
                for (const planet of planets){
                    //console.log(planet);
                    if (planet.spaceStation){
                        //console.log(planet);
                        newSpaceStations += 1;
                    }
                } 
            }
        }
        // update resource state
        this.setState({
                // No need for prevState here since 'newResource' is a complete, fresh value.
                spaceStations : newSpaceStations
            }, () => {
                console.log(`Updated Space Stations processed: ${this.state.spaceStations}`);
            });


    }

    render() {
        return
    };



};
export default MapInfo;